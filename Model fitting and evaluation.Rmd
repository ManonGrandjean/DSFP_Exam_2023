---
title: "Model fitting and evaluation"
author: "Manon Grandjean"
date: "2023-05-31"
output: html_document
---

```{r load libraries}
library(tidyverse)
library(tsibble)
library(fabletools)
library(fable)
library(feasts)
library(gridExtra)
library(caret)

options(scipen=999)
```


```{r Load and prep data}
df <- read.csv("Azure2015Data.csv")

# fix date format
df$datetime <- as.POSIXct(df$datetime, format="%Y-%m-%d %H:%M:%S", tz="UTC")

# remove duplicate rows, create logical var for failure, remove unnecessary cols, arrange temporally for easy splitting
df <- df %>%
  distinct(datetime, machineID, .keep_all = TRUE) %>%
  mutate(failureYN = case_when(failure == '' ~ 0, failure != '' ~ 1)) %>% # also errorYN?
  subset(select = -c(X, Unnamed..0)) %>%
  arrange(datetime, machineID)
```


```{r create error, failure, and component variables}
# vars in df:
# logical: (error1+2+3+4+5, failure_comp1+2+3+4, replace_comp1+2+3+4) = 13 vars
# time since: ---||--- = 13 vars


# https://stackoverflow.com/questions/71284863/time-since-last-event-of-grouped-data-in-r
df <- df %>%
  group_by(machineID) %>%
  # days since any error and any failure
  mutate(last_error = if_else(errorID != "", datetime, NA)) %>%
  mutate(last_failure = if_else(failure != "", datetime, NA)) %>%
  fill(last_error) %>%
  fill(last_failure) %>%
  mutate(daysSinceError = as.numeric(floor(difftime(datetime, last_error, tz="UTC", units="days")))) %>%
  mutate(daysSinceFailure = as.numeric(floor(difftime(datetime, last_failure, tz="UTC", units="days")))) %>%
  # daysSince vars for each type of error/failure/comp (not used in this analysis)
  mutate(
    lastError1 = if_else(errorID == "error1", datetime, NA),
    lastError2 = if_else(errorID == "error2", datetime, NA),
    lastError3 = if_else(errorID == "error3", datetime, NA),
    lastError4 = if_else(errorID == "error4", datetime, NA),
    lastError5 = if_else(errorID == "error5", datetime, NA),
    lastFailureComp1 = if_else(failure == "comp1", datetime, NA),
    lastFailureComp2 = if_else(failure == "comp2", datetime, NA),
    lastFailureComp3 = if_else(failure == "comp3", datetime, NA),
    lastFailureComp4 = if_else(failure == "comp4", datetime, NA),
    lastComp1Replacement = if_else(comp == "comp1", datetime, NA),
    lastComp2Replacement = if_else(comp == "comp2", datetime, NA),
    lastComp3Replacement = if_else(comp == "comp3", datetime, NA),
    lastComp4Replacement = if_else(comp == "comp4", datetime, NA)
  ) %>%
  fill(lastError1,lastError2,lastError3,lastError4,lastError5,lastFailureComp1,lastFailureComp2,lastFailureComp3,
       lastFailureComp4,lastComp1Replacement,lastComp2Replacement,lastComp3Replacement,lastComp4Replacement) %>%
  mutate(
    daysSinceError1 = as.numeric(floor(difftime(datetime, lastError1, tz="UTC", units="days"))),
    daysSinceError2 = as.numeric(floor(difftime(datetime, lastError2, tz="UTC", units="days"))),
    daysSinceError3 = as.numeric(floor(difftime(datetime, lastError3, tz="UTC", units="days"))),
    daysSinceError4 = as.numeric(floor(difftime(datetime, lastError4, tz="UTC", units="days"))),
    daysSinceError5 = as.numeric(floor(difftime(datetime, lastError5, tz="UTC", units="days"))),
    daysSinceFailure1 = as.numeric(floor(difftime(datetime, lastFailureComp1, tz="UTC", units="days"))),
    daysSinceFailure2 = as.numeric(floor(difftime(datetime, lastFailureComp2, tz="UTC", units="days"))),
    daysSinceFailure3 = as.numeric(floor(difftime(datetime, lastFailureComp3, tz="UTC", units="days"))),
    daysSinceFailure4 = as.numeric(floor(difftime(datetime, lastFailureComp4, tz="UTC", units="days"))),
    daysSinceReplace1 = as.numeric(floor(difftime(datetime, lastComp1Replacement, tz="UTC", units="days"))),
    daysSinceReplace2 = as.numeric(floor(difftime(datetime, lastComp2Replacement, tz="UTC", units="days"))),
    daysSinceReplace3 = as.numeric(floor(difftime(datetime, lastComp3Replacement, tz="UTC", units="days"))),
    daysSinceReplace4 = as.numeric(floor(difftime(datetime, lastComp4Replacement, tz="UTC", units="days")))
  ) %>%
  # remove unnecessary columns
  subset(select = -c(last_error,last_failure,lastError1,lastError2,lastError3,lastError4,lastError5,
                     lastFailureComp1,lastFailureComp2,lastFailureComp3,lastFailureComp4,
                     lastComp1Replacement,lastComp2Replacement,lastComp3Replacement,lastComp4Replacement))

# do I maybe need to replace NAs in daysSince vars with 0?
```


```{r Aggregate to daily}
# aggregate to daily
df$date <- as.Date(df$datetime, "%m/%d/%Y")
df_daily <- aggregate(cbind(volt,rotate,pressure,vibration)
                      ~ date + machineID,
                      df, FUN = "mean", drop = FALSE)


# get model and age info for each machine ID
df_daily <- merge(df_daily, subset(count(df, machineID, age, model), select = -c(n)), by = "machineID")

# add failure and error info for a day and machine if any
df_daily <- merge(df_daily, 
                  unique(df[df$failureYN==1,][,c("machineID","failureYN","date")]),
                  by = c("machineID", "date"), all.x = TRUE)
df_daily$failureYN <- gtools::na.replace(df_daily$failureYN, 0)

# merge df[,12:27] onto df_daily by date and machineID
df_daily <- merge(df_daily, 
                  distinct(df[,c(1,28,13:27)], machineID, date, .keep_all = TRUE),
                  by = c("machineID", "date"))

# arrange
df_daily <- arrange(df_daily, date, machineID)

# make machineID factor (because it is) so logreg will be accurate
df_daily$machineID <- as.factor(df_daily$machineID)
```


```{r Make lag predictors}
df_daily <- df_daily %>%
  group_by(machineID) %>%
  mutate(lag_1d_volt = lag(volt, n = 1),
         lag_2d_volt = lag(volt, n = 2),
         lag_3d_volt = lag(volt, n = 3),
         lag_4d_volt = lag(volt, n = 4),
         lag_5d_volt = lag(volt, n = 5),
         lag_6d_volt = lag(volt, n = 6),
         lag_7d_volt = lag(volt, n = 7),
         lag_8d_volt = lag(volt, n = 8),
         lag_9d_volt = lag(volt, n = 9),
         lag_10d_volt = lag(volt, n = 10),
         
         lag_1d_rotate = lag(rotate, n = 1),
         lag_2d_rotate = lag(rotate, n = 2),
         lag_3d_rotate = lag(rotate, n = 3),
         lag_4d_rotate = lag(rotate, n = 4),
         lag_5d_rotate = lag(rotate, n = 5),
         lag_6d_rotate = lag(rotate, n = 6),
         lag_7d_rotate = lag(rotate, n = 7),
         lag_8d_rotate = lag(rotate, n = 8),
         lag_9d_rotate = lag(rotate, n = 9),
         lag_10d_rotate = lag(rotate, n = 10),
         
         lag_1d_pressure = lag(pressure, n = 1),
         lag_2d_pressure = lag(pressure, n = 2),
         lag_3d_pressure = lag(pressure, n = 3),
         lag_4d_pressure = lag(pressure, n = 4),
         lag_5d_pressure = lag(pressure, n = 5),
         lag_6d_pressure = lag(pressure, n = 6),
         lag_7d_pressure = lag(pressure, n = 7),
         lag_8d_pressure = lag(pressure, n = 8),
         lag_9d_pressure = lag(pressure, n = 9),
         lag_10d_pressure = lag(pressure, n = 10),
         
         lag_1d_vibration = lag(vibration, n = 1),
         lag_2d_vibration = lag(vibration, n = 2),
         lag_3d_vibration = lag(vibration, n = 3),
         lag_4d_vibration = lag(vibration, n = 4),
         lag_5d_vibration = lag(vibration, n = 5),
         lag_6d_vibration = lag(vibration, n = 6),
         lag_7d_vibration = lag(vibration, n = 7),
         lag_8d_vibration = lag(vibration, n = 8),
         lag_9d_vibration = lag(vibration, n = 9),
         lag_10d_vibration = lag(vibration, n = 10)
  ) %>%
  
  # days since LAST failure
  mutate(
    SinceFailLag = lag(daysSinceFailure, 1),
    daysSinceLastFailure = case_when(
      daysSinceFailure == 0 ~ SinceFailLag+1,
      .default = daysSinceFailure)
    )
```



```{r Train + make forecasts}
# split into train and test
# train on 9 months = 75% of data = up to and including index 27300
train <- df_daily[1:27300,]
test <- df_daily[27301:36500,]
```


# Failure prediction
predictors:
- machineID (as factor) (not used, not hierarchical) (would also clash with using age + model)
- volt + rotate + pressure + vibration (IoT measures)
- age + model                           (Machine characteristics)
- daysSinceLastFailure + daysSinceError (Maintenance information)
- lag predictors



Logistic regression models:
*model1* = IoT measures (volt + rotate + pressure + vibration)
*model2* = IoT measures + machine characteristics (age + model)

*model3* = IoT measures + daysSinceLastFailure 
*model4* = IoT measures + daysSinceLastFailure + machine characteristics
*model5* = IoT measures + daysSinceLastFailure + daysSinceError         
*model6* = IoT measures + daysSinceLastFailure + daysSinceError + machine characteristics 
*model7* = IoT measures + daysSinceError
*model8* = IoT measures + daysSinceError + machine characteristics

*model9* = IoT measures and lag predictors
*model10* = IoT measures, machine characteristics, and lag predictors
*model11* = IoT measures and lag predictors + daysSinceLastFailure + daysSinceError
*model12* = IoT measures, machine characteristics, and lag predictors + daysSinceLastFailure + daysSinceError    


```{r Fitting logistic regression models}

model1 <- glm(failureYN ~ volt + rotate + pressure + vibration, 
              family=binomial(link='logit'), 
              data = train)

model2 <- glm(failureYN ~ volt + rotate + pressure + vibration + age + model, 
              family=binomial(link='logit'), 
              data = train)


model3 <- glm(failureYN ~ volt + rotate + pressure + vibration + daysSinceLastFailure, 
              family=binomial(link='logit'), 
              data = train)
model4 <- glm(failureYN ~ volt + rotate + pressure + vibration + daysSinceLastFailure + age + model, 
              family=binomial(link='logit'), 
              data = train)
model5 <- glm(failureYN ~ volt + rotate + pressure + vibration + daysSinceLastFailure + daysSinceError, 
              family=binomial(link='logit'), 
              data = train)
model6 <- glm(failureYN ~ volt + rotate + pressure + vibration + daysSinceLastFailure + daysSinceError + age + model, 
              family=binomial(link='logit'), 
              data = train)


model7 <- glm(failureYN ~ volt + rotate + pressure + vibration + daysSinceError, 
              family=binomial(link='logit'), 
              data = train)

model8 <- glm(failureYN ~ volt + rotate + pressure + vibration + daysSinceError + age + model, 
              family=binomial(link='logit'), 
              data = train)


# with lag predictors:
model9 <- glm(failureYN ~ volt + rotate + pressure + vibration + 
                lag_1d_volt + lag_2d_volt + lag_3d_volt + lag_4d_volt + lag_5d_volt + lag_6d_volt + lag_7d_volt + lag_8d_volt +
                lag_9d_volt + lag_10d_volt + lag_1d_rotate + lag_2d_rotate + lag_3d_rotate + lag_4d_rotate + lag_5d_rotate +
                lag_6d_rotate + lag_7d_rotate + lag_8d_rotate + lag_9d_rotate + lag_10d_rotate + 
                lag_1d_pressure + lag_2d_pressure + lag_3d_pressure + lag_4d_pressure + lag_5d_pressure +
                lag_6d_pressure + lag_7d_pressure + lag_8d_pressure + lag_9d_pressure + lag_10d_pressure +
                lag_1d_vibration + lag_2d_vibration + lag_3d_vibration + lag_4d_vibration + lag_5d_vibration + 
                lag_6d_vibration + lag_7d_vibration + lag_8d_vibration + lag_9d_vibration + lag_10d_vibration, 
              family=binomial(link='logit'), 
              data = train)

model10 <- glm(failureYN ~ volt + rotate + pressure + vibration + age + model +
                lag_1d_volt + lag_2d_volt + lag_3d_volt + lag_4d_volt + lag_5d_volt + lag_6d_volt + lag_7d_volt + lag_8d_volt +
                lag_9d_volt + lag_10d_volt + lag_1d_rotate + lag_2d_rotate + lag_3d_rotate + lag_4d_rotate + lag_5d_rotate +
                lag_6d_rotate + lag_7d_rotate + lag_8d_rotate + lag_9d_rotate + lag_10d_rotate + 
                lag_1d_pressure + lag_2d_pressure + lag_3d_pressure + lag_4d_pressure + lag_5d_pressure +
                lag_6d_pressure + lag_7d_pressure + lag_8d_pressure + lag_9d_pressure + lag_10d_pressure +
                lag_1d_vibration + lag_2d_vibration + lag_3d_vibration + lag_4d_vibration + lag_5d_vibration + 
                lag_6d_vibration + lag_7d_vibration + lag_8d_vibration + lag_9d_vibration + lag_10d_vibration, 
              family=binomial(link='logit'), 
              data = train)

model11 <- glm(failureYN ~ volt + rotate + pressure + vibration + daysSinceError + 
                lag_1d_volt + lag_2d_volt + lag_3d_volt + lag_4d_volt + lag_5d_volt + lag_6d_volt + lag_7d_volt + lag_8d_volt +
                lag_9d_volt + lag_10d_volt + lag_1d_rotate + lag_2d_rotate + lag_3d_rotate + lag_4d_rotate + lag_5d_rotate +
                lag_6d_rotate + lag_7d_rotate + lag_8d_rotate + lag_9d_rotate + lag_10d_rotate + 
                lag_1d_pressure + lag_2d_pressure + lag_3d_pressure + lag_4d_pressure + lag_5d_pressure +
                lag_6d_pressure + lag_7d_pressure + lag_8d_pressure + lag_9d_pressure + lag_10d_pressure +
                lag_1d_vibration + lag_2d_vibration + lag_3d_vibration + lag_4d_vibration + lag_5d_vibration + 
                lag_6d_vibration + lag_7d_vibration + lag_8d_vibration + lag_9d_vibration + lag_10d_vibration, 
              family=binomial(link='logit'), 
              data = train)

model12 <- glm(failureYN ~ volt + rotate + pressure + vibration + age + model + daysSinceError + 
                lag_1d_volt + lag_2d_volt + lag_3d_volt + lag_4d_volt + lag_5d_volt + lag_6d_volt + lag_7d_volt + lag_8d_volt +
                lag_9d_volt + lag_10d_volt + lag_1d_rotate + lag_2d_rotate + lag_3d_rotate + lag_4d_rotate + lag_5d_rotate +
                lag_6d_rotate + lag_7d_rotate + lag_8d_rotate + lag_9d_rotate + lag_10d_rotate + 
                lag_1d_pressure + lag_2d_pressure + lag_3d_pressure + lag_4d_pressure + lag_5d_pressure +
                lag_6d_pressure + lag_7d_pressure + lag_8d_pressure + lag_9d_pressure + lag_10d_pressure +
                lag_1d_vibration + lag_2d_vibration + lag_3d_vibration + lag_4d_vibration + lag_5d_vibration + 
                lag_6d_vibration + lag_7d_vibration + lag_8d_vibration + lag_9d_vibration + lag_10d_vibration, 
              family=binomial(link='logit'), 
              data = train)

# Warning: glm.fit: algorithm did not converge
# https://www.statology.org/glm-fit-algorithm-did-not-converge/
```


```{r model summaries}
summary(model1)
summary(model2)
summary(model3)
summary(model4)
summary(model5)
summary(model6)
summary(model7)
summary(model8)
summary(model9)
summary(model10)
summary(model11)
summary(model12)
```




```{r m12 inspecting estimates for each predictor}
s12 <- summary(model12)
estimates12 <- s12$coefficients[2:50,1]
coef12 <- as.data.frame(estimates12)
coef12 <- cbind(Predictor = rownames(coef12), coef12)
coef12$order <- 1:49
coef12 <- mutate(coef12, 
                 category = case_when(Predictor == 'volt' ~ 'IoT measure',
                                      Predictor == 'rotate' ~ 'IoT measure',
                                      Predictor == 'pressure' ~ 'IoT measure',
                                      Predictor == 'vibration' ~ 'IoT measure',
                                      Predictor == 'age' ~ 'Machine characteristic',
                                      Predictor == 'modelmodel2' ~ 'Machine characteristic',
                                      Predictor == 'modelmodel3' ~ 'Machine characteristic',
                                      Predictor == 'modelmodel4' ~ 'Machine characteristic',
                                      Predictor == 'daysSinceError' ~ 'Maintenance info',
                                      grepl('d_volt',Predictor) ~ 'Lag volt',
                                      grepl('d_rotate',Predictor) ~ 'Lag rotate',
                                      grepl('d_pressure',Predictor) ~ 'Lag pressure',
                                      grepl('d_vibration',Predictor) ~ 'Lag vibration'
                                      ))

options(scipen=0)

ggplot(coef12, aes(x = estimates12, y = reorder(Predictor, -order), fill = reorder(category, order)))+
  geom_col()+
  ggtitle("Estimates for model 12")+
  theme_light()+
  xlab("Estimate")+
  ylab("Predictor")+
  scale_fill_discrete(name = "")

options(scipen=999)
```

```{r m9}
s9 <- summary(model9)
estimates9 <- s9$coefficients[2:45,1]
coef9 <- as.data.frame(estimates9)
coef9 <- cbind(Predictor = rownames(coef9), coef9)
coef9$order <- 1:44
coef9 <- mutate(coef9, 
                 category = case_when(Predictor == 'volt' ~ 'IoT measure',
                                      Predictor == 'rotate' ~ 'IoT measure',
                                      Predictor == 'pressure' ~ 'IoT measure',
                                      Predictor == 'vibration' ~ 'IoT measure',
                                      grepl('d_volt',Predictor) ~ 'Lag volt',
                                      grepl('d_rotate',Predictor) ~ 'Lag rotate',
                                      grepl('d_pressure',Predictor) ~ 'Lag pressure',
                                      grepl('d_vibration',Predictor) ~ 'Lag vibration'
                                      ))

options(scipen=0)

ggplot(coef9, aes(x = estimates9, y = reorder(Predictor, -order), fill = reorder(category, order)))+
  geom_col()+
  ggtitle("Estimates for model 9")+
  theme_light()+
  xlab("Estimate")+
  ylab("Predictor")+
  scale_fill_discrete(name = "")

options(scipen=999)
```



```{r LogReg Model predictions on test set}
# Save probability of failure (PoF) from each model into the test set
test$PoF_model1 <- predict(model1, newdata = test, type = 'response')
test$PoF_model2 <- predict(model2, newdata = test, type = 'response')
test$PoF_model3 <- predict(model3, newdata = test, type = 'response')
test$PoF_model4 <- predict(model4, newdata = test, type = 'response')
test$PoF_model5 <- predict(model5, newdata = test, type = 'response')
test$PoF_model6 <- predict(model6, newdata = test, type = 'response')
test$PoF_model7 <- predict(model7, newdata = test, type = 'response')
test$PoF_model8 <- predict(model8, newdata = test, type = 'response')
test$PoF_model9 <- predict(model9, newdata = test, type = 'response')
test$PoF_model10 <- predict(model10, newdata = test, type = 'response')
test$PoF_model11 <- predict(model11, newdata = test, type = 'response')
test$PoF_model12 <- predict(model12, newdata = test, type = 'response')
#test$PoF_model0 <- predict(model0, newdata = test, type = 'response')

```


```{r plot PoF vs real failure}
plotPoF <- function(machine){
  gridExtra::grid.arrange(ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_line(aes(y=PoF_model1))+
                            theme_light()+ylab("")+xlab("Model 1"),
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_line(aes(y=PoF_model9))+
                            theme_light()+ylab("")+xlab("Model 9"),
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Model 12"),
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity")+
                            theme_light()+ylab("")+xlab("Actual failure"),
                          ncol = 1, left = "Probability of failure (PoF)"
  )
}

plotPoF_allmodels <- function(machine){
  ggplot(test[test$machineID==machine,], aes(x=date))+
  geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5)+
  geom_line(aes(y=PoF_model1), color = "#F8766D")+
  geom_line(aes(y=PoF_model2), color = "#E58700")+
  geom_line(aes(y=PoF_model7), color = "#DBD516")+ # gul
  geom_line(aes(y=PoF_model8), color = "#6BB100")+
  geom_line(aes(y=PoF_model9), color = "#00C0AF")+
  geom_line(aes(y=PoF_model10), color = "#00B0F6")+
  geom_line(aes(y=PoF_model11), color = "#B983FF")+
  geom_line(aes(y=PoF_model12), color = "#FD61D1")+
  geom_line(aes(y=PoF_model0), color = "#FFA18A")+
  theme_light()
}

plotPoF2 <- function(machine){
  gridExtra::grid.arrange(ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model1))+
                            theme_light()+ylab("")+xlab("Model 1"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model2))+
                            theme_light()+ylab("")+xlab("Model 2"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model3))+
                            theme_light()+ylab("")+xlab("Model 3"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model4))+
                            theme_light()+ylab("")+xlab("Model 4"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model5))+
                            theme_light()+ylab("")+xlab("Model 5"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model6))+
                            theme_light()+ylab("")+xlab("Model 6"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model7))+
                            theme_light()+ylab("")+xlab("Model 7"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model8))+
                            theme_light()+ylab("")+xlab("Model 8"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model9))+
                            theme_light()+ylab("")+xlab("Model 9"),
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model10))+
                            theme_light()+ylab("")+xlab("Model 10"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model11))+
                            theme_light()+ylab("")+xlab("Model 11"),
                          
                          ggplot(test[test$machineID==machine,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Model 12"),
                          
                          #ggplot(test[test$machineID==machine,], aes(x=date))+
                          #  geom_bar(aes(y=failureYN), stat = "identity")+
                          #  theme_light()+ylab("")+xlab("Actual failure"),
                          ncol = 3, left = "Probability of failure (PoF)"
  )
}



plot_IoT_PoF <- function(machine, title){
 gridExtra::grid.arrange(
  ggplot(test[test$machineID==machine,], aes(x=date))+geom_line(aes(y=volt))+theme_light()+xlab(""),
  ggplot(test[test$machineID==machine,], aes(x=date))+geom_line(aes(y=rotate))+theme_light()+xlab(""),
  ggplot(test[test$machineID==machine,], aes(x=date))+geom_line(aes(y=pressure))+theme_light()+xlab(""),
  ggplot(test[test$machineID==machine,], aes(x=date))+geom_line(aes(y=vibration))+theme_light()+xlab(""),
  ggplot(test[test$machineID==machine,], aes(x=date))+geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
    geom_line(aes(y=PoF_model12))+theme_light()+ylab("Failure"),
  ncol = 1, heights = c(1,1,1,1,1.3), top = title
) 
}


#plotPoF(21)
#plotPoF_allmodels(21)
plotPoF2(1)
#plot_IoT_PoF(21, "PoF machine 21")
```

```{r plot examples of predictions for model 12 (out-of-sample)}
gridExtra::grid.arrange(ggplot(test[test$machineID==1,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 1"),
                        
                        ggplot(test[test$machineID==2,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 2"),
                        
                        ggplot(test[test$machineID==3,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 3"),
                        
                        ggplot(test[test$machineID==4,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 4"),
                        
                        ggplot(test[test$machineID==5,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 5"),
                        
                        ggplot(test[test$machineID==6,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 6"),
                        
                        ggplot(test[test$machineID==7,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 7"),
                        
                        ggplot(test[test$machineID==8,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 8"),
                        
                        ggplot(test[test$machineID==9,], aes(x=date))+
                            geom_bar(aes(y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+
                            theme_light()+ylab("")+xlab("Machine 9"),
                          
                          ncol = 3, left = "Probability of failure (PoF)"
                        )
```



```{r Confusion matrices}
# Set decision boundary
decision_boundary <- 0.5

# Create 0-1 predictions from models
test <- test %>%
  mutate(
    Failure_m1 = ifelse(PoF_model1 < decision_boundary, 0, 1),
    Failure_m2 = ifelse(PoF_model2 < decision_boundary, 0, 1),
    Failure_m3 = ifelse(PoF_model3 < decision_boundary, 0, 1),
    Failure_m4 = ifelse(PoF_model4 < decision_boundary, 0, 1),
    Failure_m5 = ifelse(PoF_model5 < decision_boundary, 0, 1),
    Failure_m6 = ifelse(PoF_model6 < decision_boundary, 0, 1),
    Failure_m7 = ifelse(PoF_model7 < decision_boundary, 0, 1),
    Failure_m8 = ifelse(PoF_model8 < decision_boundary, 0, 1),
    Failure_m9 = ifelse(PoF_model9 < decision_boundary, 0, 1),
    Failure_m10 = ifelse(PoF_model10 < decision_boundary, 0, 1),
    Failure_m11 = ifelse(PoF_model11 < decision_boundary, 0, 1),
    Failure_m12 = ifelse(PoF_model12 < decision_boundary, 0, 1)
    #Failure_m0 = ifelse(PoF_model0 < decision_boundary, 0, 1),
  )

ConfMat1 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m1), positive = "1") #err
ConfMat2 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m2), positive = "1") #err
ConfMat3 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m3), positive = "1")
ConfMat4 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m4), positive = "1")
ConfMat5 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m5), positive = "1")
ConfMat6 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m6), positive = "1")
ConfMat7 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m7), positive = "1")
ConfMat8 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m8), positive = "1")
ConfMat9 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m9), positive = "1")
ConfMat10 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m10), positive = "1")
ConfMat11 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m11), positive = "1")
ConfMat12 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m12), positive = "1")
#ConfMat0 <- confusionMatrix(reference = as.factor(test$failureYN), as.factor(test$Failure_m0), positive = "1") #err

ConfMat1
```



# Forecasts

```{r prepare data for forecasting}
# train and test tsibbles
tsrain <- as_tsibble(train, key = machineID, index = date)
tsest <- as_tsibble(test, key = machineID, index = date)

# empty data to fill with forecasts
future_Q4 <- tsest
# machineID, date, age, and model stay the same (we know these ex ante)
# lag values in the first n rows per machine are actually valid, but don't know how to preserve those
future_Q4[,3:6] <- NA
future_Q4[,9:82] <- NA
future_Q4 <- as_tsibble(future_Q4, key = machineID, index = date)

```


```{r functions to return report and forecast plot}
machine_report <- function(fit, id){
  report(fit[fit$machineID == id,])
}

machine_forecast <- function(fc, actual, id){
  fc2 <- fc[fc$machineID == id,]
  actual2 <- actual[actual$machineID == id,]
  
  fc2 |>
    autoplot(actual2, alpha = 0.5)+
    theme_light()
}
```


Variables to forecast:
*needs forecasting:* volt + rotate + pressure + vibration + daysSinceError
*do not need forecasting:* age + model + machineID + date + all lag predictors (can be calculated after IoT forecasts)


```{r Fit forecast models}
# fit all (TSLM + Seasonal Na√Øve model) to compare
fit_volt <- model(tsrain, SN=SNAIVE(volt), LM=TSLM(volt ~ trend() + season()))
fit_rotate <- model(tsrain, SN=SNAIVE(rotate), LM=TSLM(rotate ~ trend() + season()))
fit_pressure <- model(tsrain, SN=SNAIVE(pressure), LM=TSLM(pressure ~ trend() + season()))
fit_vibration <- model(tsrain, SN=SNAIVE(vibration), LM=TSLM(vibration ~ trend() + season()))
fit_daysSinceError <- model(tsrain, SN=SNAIVE(daysSinceError), LM=TSLM(daysSinceError ~ trend() + season()))

# produce forecasts
fc_volt <- forecast(fit_volt, new_data = future_Q4[,1:2])
fc_rotate <- forecast(fit_rotate, new_data = future_Q4[,1:2])
fc_pressure <- forecast(fit_pressure, new_data = future_Q4[,1:2])
fc_vibration <- forecast(fit_vibration, new_data = future_Q4[,1:2])
fc_daysSinceError <- forecast(fit_daysSinceError, new_data = future_Q4[,1:2])
```


```{r Test forecast accuracy of the different models}
# Point forecast accuracy: How much error?
# The average of each score across machines

# OUT OF SAMPLE:
fc_volt %>%
  accuracy(rbind(tsrain, tsest)) %>% select(.model, machineID, RMSE, MAPE) %>%
  aggregate(cbind(RMSE, MAPE) ~ .model, FUN = "mean", drop = FALSE)

fc_rotate %>% 
  accuracy(rbind(tsrain, tsest)) %>% select(.model, machineID, RMSE, MAPE) %>%
  aggregate(cbind(RMSE, MAPE) ~ .model, FUN = "mean", drop = FALSE)

fc_pressure %>%
  accuracy(rbind(tsrain, tsest)) %>% select(.model, machineID, RMSE, MAPE) %>%
  aggregate(cbind(RMSE, MAPE) ~ .model, FUN = "mean", drop = FALSE)

fc_vibration %>%
  accuracy(rbind(tsrain, tsest)) %>% select(.model, machineID, RMSE, MAPE) %>%
  aggregate(cbind(RMSE, MAPE) ~ .model, FUN = "mean", drop = FALSE)

fc_daysSinceError %>%
  accuracy(rbind(tsrain, tsest)) %>% select(.model, machineID, RMSE, MAPE) %>%
  aggregate(cbind(RMSE, MAPE) ~ .model, FUN = "mean", drop = FALSE)




# Distributional forecast accuracy: Continuous ranked probability score (CRPS)
fc_volt %>% accuracy(rbind(tsrain, tsest), measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)

fc_rotate %>% accuracy(rbind(tsrain, tsest), measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)

fc_pressure %>% accuracy(rbind(tsrain, tsest), measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)

fc_vibration %>% accuracy(rbind(tsrain, tsest), measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)

fc_daysSinceError %>% accuracy(rbind(tsrain, tsest), measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)

# Visualized: (Q3 + Q4)
Q3Q4 <- rbind(tsrain[tsrain$date > "2015-05-31",],tsest)
machine_forecast(fc_volt, Q3Q4, 1)
machine_forecast(fc_rotate, Q3Q4, 1)
machine_forecast(fc_pressure, Q3Q4, 1)
machine_forecast(fc_vibration, Q3Q4, 1)
machine_forecast(fc_daysSinceError, Q3Q4, 1)

machine_forecast(fc_volt, tsest, 1)
machine_forecast(fc_rotate, tsest, 1)
machine_forecast(fc_pressure, tsest, 1)
machine_forecast(fc_vibration, tsest, 1)
machine_forecast(fc_daysSinceError, tsest, 1)
```



```{r Fit winning forecast models with bootsraps}
# fit all (basic TSLM model) ([also fit something else to compare and pick TSLM?])
fit_volt <- model(tsrain, TSLM(volt ~ trend() + season()))
fit_rotate <- model(tsrain, TSLM(rotate ~ trend() + season()))
fit_pressure <- model(tsrain, TSLM(pressure ~ trend() + season()))
fit_vibration <- model(tsrain, TSLM(vibration ~ trend() + season()))
fit_daysSinceError <- model(tsrain, TSLM(daysSinceError ~ trend() + season()))

# forecast (with/without bootstrapping) (only TSLM)
fc_volt <- forecast(fit_volt, new_data = future_Q4[,1:2])
fc_volt_bs5 <- forecast(fit_volt, new_data = future_Q4[,1:2], bootstrap=T,times=5)
fc_volt_bs100 <- forecast(fit_volt, new_data = future_Q4[,1:2], bootstrap=T,times=100)

fc_rotate <- forecast(fit_rotate, new_data = future_Q4[,1:2])
fc_rotate_bs5 <- forecast(fit_rotate, new_data = future_Q4[,1:2], bootstrap=T,times=5)
fc_rotate_bs100 <- forecast(fit_rotate, new_data = future_Q4[,1:2], bootstrap=T,times=100)

fc_pressure <- forecast(fit_pressure, new_data = future_Q4[,1:2])
fc_pressure_bs5 <- forecast(fit_pressure, new_data = future_Q4[,1:2], bootstrap=T,times=5)
fc_pressure_bs100 <- forecast(fit_pressure, new_data = future_Q4[,1:2], bootstrap=T,times=100)

fc_vibration <- forecast(fit_vibration, new_data = future_Q4[,1:2])
fc_vibration_bs5 <- forecast(fit_vibration, new_data = future_Q4[,1:2], bootstrap=T,times=5)
fc_vibration_bs100 <- forecast(fit_vibration, new_data = future_Q4[,1:2], bootstrap=T,times=100)

fc_daysSinceError <- forecast(fit_daysSinceError, new_data = future_Q4[,1:2])
fc_daysSinceError_bs5 <- forecast(fit_daysSinceError, new_data = future_Q4[,1:2], bootstrap=T,times=5)
fc_daysSinceError_bs100 <- forecast(fit_daysSinceError, new_data = future_Q4[,1:2], bootstrap=T,times=100)
```



```{r Evaluating bootstrap models}
complete_data <- rbind(tsrain, tsest)

# Distributional forecast accuracy: Continuous ranked probability score (CRPS)
fc_daysSinceError %>%
  accuracy(complete_data, measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)

# getting accuracy from bootstrapped models should work!
# https://www.r-bloggers.com/2019/10/non-gaussian-forecasting-using-fable/

acc_volt_bs5 <- fc_volt_bs5 %>%
  accuracy(complete_data, measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# took from 18:24 to 18:42 = 18 mins

acc_rotate_bs5 <- fc_rotate_bs5 %>%
  accuracy(complete_data, measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# from 19:14 to 19:32 = 18 mins

acc_pressure_bs5 <- fc_pressure_bs5 %>%
  accuracy(complete_data, measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# from 19:32 to : = 18 mins

acc_vibration_bs5 <- fc_vibration_bs5 %>%
  accuracy(complete_data, measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# from : to : = 18 mins

acc_daysSinceError_bs5 <- fc_daysSinceError_bs5 %>%
  accuracy(complete_data, measures = list(crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# from : to : = 18 mins



# point accuracy:
fc_volt %>%
  accuracy(complete_data) %>% select(.model, machineID, RMSE, MAPE) %>%
  aggregate(cbind(RMSE, MAPE) ~ .model, FUN = "mean", drop = FALSE)

```





```{r the 100 botstraps }
acc_volt_bs100 <- fc_volt_bs100 %>%
  accuracy(complete_data, measures = list(rmse=RMSE, mape=MAPE, crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(rmse, mape, crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# from : to : = mins


acc_rotate_bs100 <- fc_rotate_bs100 %>%
  accuracy(complete_data, measures = list(rmse=RMSE, mape=MAPE, crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(rmse, mape, crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# from 21:20 to 21:39 = 19 mins


acc_pressure_bs100 <- fc_pressure_bs100 %>%
  accuracy(complete_data, measures = list(rmse=RMSE, mape=MAPE, crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(rmse, mape, crps, skill) ~ .model, FUN = "mean", drop = FALSE)
 #from 21:39 to 21:58 = 19 mins


acc_vibration_bs100 <- fc_vibration_bs100 %>%
  accuracy(complete_data, measures = list(rmse=RMSE, mape=MAPE, crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(rmse, mape, crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# from : to : = 20 mins


acc_daysSinceError_bs100 <- fc_daysSinceError_bs100 %>%
  accuracy(complete_data, measures = list(rmse=RMSE, mape=MAPE, crps=CRPS, skill=skill_score(CRPS))) %>%
  aggregate(cbind(rmse, mape, crps, skill) ~ .model, FUN = "mean", drop = FALSE)
# from : to : = 20 mins


# point accuracy:
fc_daysSinceError_bs100 %>%
  accuracy(complete_data) %>% select(.model, machineID, RMSE, MAPE) %>%
  aggregate(cbind(RMSE, MAPE) ~ .model, FUN = "mean", drop = FALSE)
```






```{r Inspect residuals}
# FPP3 5.4


theme_set(theme_light())

# define function to show residuals plots for given machineID
PlotResids <- function(machineNr){
  name <- paste("Machine", as.character(machineNr))
  print(gg_tsresiduals(fit_volt[fit_volt$machineID == machineNr,])+labs(title = "Volt", subtitle = name))
  print(gg_tsresiduals(fit_rotate[fit_rotate$machineID == machineNr,])+labs(title = "Rotate", subtitle = name))
  print(gg_tsresiduals(fit_pressure[fit_pressure$machineID == machineNr,])+labs(title = "Pressure", subtitle = name))
  print(gg_tsresiduals(fit_vibration[fit_vibration$machineID == machineNr,])+labs(title = "Vibration", subtitle = name))
  print(gg_tsresiduals(fit_daysSinceError[fit_daysSinceError$machineID == machineNr,])+labs(title = "Days Since Error", subtitle = name))
}

# plot residuals for a specific machineID
PlotResids(5)

# Normality of residuals
#gg_tsresiduals(fit_volt[fit_volt$machineID == 1,])+labs(title = "Volt", subtitle = "Machine 1")
#gg_tsresiduals(fit_rotate[fit_rotate$machineID == 1,])+labs(title = "Rotate", subtitle = "Machine 1")
#gg_tsresiduals(fit_pressure[fit_pressure$machineID == 1,])+labs(title = "Pressure", subtitle = "Machine 1")
#gg_tsresiduals(fit_vibration[fit_vibration$machineID == 1,])+labs(title = "Vibration", subtitle = "Machine 1")
#gg_tsresiduals(fit_daysSinceError[fit_daysSinceError$machineID == 1,])+labs(title = "Days Since Error", subtitle = "Machine 1")
# the residuals are not homoschedastic :(

# portmanteau test for autocorrelation - do the residuals come from white noise?
augment(fit_volt)%>%
  features(.innov, ljung_box, lag = 7)
# lb_pvalues are very small (on most machines), so it seems very, very unlikely that this is just white noise
```

```{r Residual plots extra}

fit_volt[[2]][[1]]$fit$residuals # machine 1
plot(type = "l", x = fit_volt[[2]][[1]]$data$date, y = fit_volt[[2]][[1]]$fit$residuals)
plot(type = "h", x = fit_volt[[2]][[1]]$fit$residuals)
hist(fit_volt[[2]][[1]]$fit$residuals, breaks = 23)
# technically, you could get the average residuals (that would be misleading though?) instead just one long list of residuals for each predictor variable. 

# what is the average residual? (ideally 0) (and ideally with no trend over time)
mean(fit_volt[[2]][[1]]$fit$residuals)

ggplot(data = NULL, aes(x = fit_volt[[2]][[1]]$data$date, y = fit_volt[[2]][[1]]$fit$residuals))+
  geom_point()+
  geom_smooth()




# Add together all machines (for each forecast variable)
machineID <-  c()
volt_dates100 <- c()
volt_resids100 <- c()
rotate_resids100 <- c()
pressure_resids100 <- c()
vibration_resids100 <- c()
daysSinceError_resids100 <- c()

# loop through every machineID and gather residuals data
for(i in 1:100) {
  machineID <-  c(machineID, i)
  volt_dates100 <- c(volt_dates100, as.character(fit_volt[[2]][[i]]$data$date))
  volt_resids100 <- c(volt_resids100, fit_volt[[2]][[i]]$fit$residuals)
  rotate_resids100 <- c(rotate_resids100, fit_rotate[[2]][[i]]$fit$residuals)
  pressure_resids100 <- c(pressure_resids100, fit_pressure[[2]][[i]]$fit$residuals)
  vibration_resids100 <- c(vibration_resids100, fit_vibration[[2]][[i]]$fit$residuals)
  daysSinceError_resids100 <- c(daysSinceError_resids100, fit_daysSinceError[[2]][[i]]$fit$residuals)
}

# save as data frame
residuals_df <- data.frame(machineID, as.Date(volt_dates100), 
                             volt_resids100, rotate_resids100, pressure_resids100, 
                             vibration_resids100, daysSinceError_resids100)

# plot residuals for all machines aggregated
ggplot(data = residuals_df, aes(x = as.Date.volt_dates100., y = volt_resids100))+
  geom_point(alpha = 0.1)+
  geom_smooth()+
  labs(title = "Volt residuals (all 100 machines)", x = "Date", y = "Residuals")

ggplot(data = residuals_df, aes(x = as.Date.volt_dates100., y = rotate_resids100))+
  geom_point(alpha = 0.1)+
  geom_smooth()+
  labs(title = "Rotate residuals (all 100 machines)", x = "Date", y = "Residuals")

ggplot(data = residuals_df, aes(x = as.Date.volt_dates100., y = pressure_resids100))+
  geom_point(alpha = 0.1)+
  geom_smooth()+
  labs(title = "Pressure residuals (all 100 machines)", x = "Date", y = "Residuals")

ggplot(data = residuals_df, aes(x = as.Date.volt_dates100., y = vibration_resids100))+
  geom_point(alpha = 0.1)+
  geom_smooth()+
  labs(title = "Vibration residuals (all 100 machines)", x = "Date", y = "Residuals")

ggplot(data = residuals_df, aes(x = as.Date.volt_dates100., y = daysSinceError_resids100))+
  geom_point(alpha = 0.1)+
  geom_smooth()+
  labs(title = "Days since Error residuals (all 100 machines)", x = "Date", y = "Residuals")
```



```{r ACF}
# make a tsibble
residuals_tsibble <- as_tsibble(residuals_df, key = machineID, index = as.Date.volt_dates100.)

ACF(residuals_tsibble, y = volt_resids100)[1:24,2:3] %>% autoplot(.vars = acf)
acf(residuals_tsibble$volt_resids100, plot = TRUE, lag.max = 24)

acf_volt <- ACF(residuals_tsibble, y = volt_resids100)
acf_volt_2 <- acf(acf_volt$acf, lag.max = 24)
plot(acf_volt_2[1:24])

acf_rotate <- acf(ACF(residuals_tsibble, y = rotate_resids100)$acf, lag.max = 24)
acf_pressure <- acf(ACF(residuals_tsibble, y = pressure_resids100)$acf, lag.max = 24)
acf_vibration <- acf(ACF(residuals_tsibble, y = vibration_resids100)$acf, lag.max = 24)
acf_dayssince <- acf(ACF(residuals_tsibble, y = daysSinceError_resids100)$acf, lag.max = 24)

plot(acf_volt_2[1:24], main = "Volt Autocorrelation Function (all machines)")
plot(acf_rotate[1:24], main = "Rotate Autocorrelation Function (all machines)")
plot(acf_pressure[1:24], main = "Pressure Autocorrelation Function (all machines)")
plot(acf_vibration[1:24], main = "Vibration Autocorrelation Function (all machines)")
plot(acf_dayssince[1:24], main = "Days Since Error Autocorrelation Function (all machines)")


# something must be wrong if daysSinceError doesn't have high autocorrelation. - At least in the first lags....
```



# Forecasts + Failure prediction


```{r fill in the rest of the predictors for the LogReg (Q4 + Q1)}
# glue together mean forecast values in future_Q4
future_Q4$volt <- fc_volt$.mean
future_Q4$rotate <- fc_rotate$.mean
future_Q4$pressure <- fc_pressure$.mean
future_Q4$vibration <- fc_vibration$.mean
future_Q4$daysSinceError <- fc_daysSinceError$.mean

# ALTERNATIVE: using the forecasts from the 100 * bootstrap model
#future_Q4$volt <- fc_volt_bs100$.mean
#future_Q4$rotate <- fc_rotate_bs100$.mean
#future_Q4$pressure <- fc_pressure_bs100$.mean
#future_Q4$vibration <- fc_vibration_bs100$.mean
#future_Q4$daysSinceError <- fc_daysSinceError_bs100$.mean

# make lag predictors (some rows based on real data, rest on forecasts)
future_Q4 <- rbind(tsrain[tsrain$date > "2015-09-20",], future_Q4) %>% # grab last 10 days of training set
  arrange(machineID, date) %>%
  group_by(machineID) %>%
  mutate(lag_1d_volt = lag(volt, n = 1),
         lag_2d_volt = lag(volt, n = 2),
         lag_3d_volt = lag(volt, n = 3),
         lag_4d_volt = lag(volt, n = 4),
         lag_5d_volt = lag(volt, n = 5),
         lag_6d_volt = lag(volt, n = 6),
         lag_7d_volt = lag(volt, n = 7),
         lag_8d_volt = lag(volt, n = 8),
         lag_9d_volt = lag(volt, n = 9),
         lag_10d_volt = lag(volt, n = 10),
         
         lag_1d_rotate = lag(rotate, n = 1),
         lag_2d_rotate = lag(rotate, n = 2),
         lag_3d_rotate = lag(rotate, n = 3),
         lag_4d_rotate = lag(rotate, n = 4),
         lag_5d_rotate = lag(rotate, n = 5),
         lag_6d_rotate = lag(rotate, n = 6),
         lag_7d_rotate = lag(rotate, n = 7),
         lag_8d_rotate = lag(rotate, n = 8),
         lag_9d_rotate = lag(rotate, n = 9),
         lag_10d_rotate = lag(rotate, n = 10),
         
         lag_1d_pressure = lag(pressure, n = 1),
         lag_2d_pressure = lag(pressure, n = 2),
         lag_3d_pressure = lag(pressure, n = 3),
         lag_4d_pressure = lag(pressure, n = 4),
         lag_5d_pressure = lag(pressure, n = 5),
         lag_6d_pressure = lag(pressure, n = 6),
         lag_7d_pressure = lag(pressure, n = 7),
         lag_8d_pressure = lag(pressure, n = 8),
         lag_9d_pressure = lag(pressure, n = 9),
         lag_10d_pressure = lag(pressure, n = 10),
         
         lag_1d_vibration = lag(vibration, n = 1),
         lag_2d_vibration = lag(vibration, n = 2),
         lag_3d_vibration = lag(vibration, n = 3),
         lag_4d_vibration = lag(vibration, n = 4),
         lag_5d_vibration = lag(vibration, n = 5),
         lag_6d_vibration = lag(vibration, n = 6),
         lag_7d_vibration = lag(vibration, n = 7),
         lag_8d_vibration = lag(vibration, n = 8),
         lag_9d_vibration = lag(vibration, n = 9),
         lag_10d_vibration = lag(vibration, n = 10)
  )

# remove that last 10 days of tsrain again
future_Q4 <- future_Q4[future_Q4$date > "2015-09-30",]
```


```{r Failure prediction on forecasts (2015 Q4)}
# Save predictions
future_Q4$PoF_model12 <- predict(model12, newdata = future_Q4, type = 'response')

# Set decision boundary
decision_boundary <- 0.5

# Create 0-1 predictions from models
future_Q4 <- future_Q4 %>%
  mutate(Failure_m12 = ifelse(PoF_model12 < decision_boundary, 0, 1))

# Visualize
showFCandFP <- function(machine){
  grid.arrange(
    ggplot()+geom_line(data = future_Q4[future_Q4$machineID==machine,], aes(x=date,y=volt), color = "#4E84C4")+
      geom_line(data = tsrain[tsrain$date > "2015-08-01"& tsrain$machineID==machine,], aes(x=date,y=volt))+
      theme_light()+xlab(""),
    ggplot()+geom_line(data = future_Q4[future_Q4$machineID==machine,], aes(x=date,y=rotate), color = "#52854C")+
      geom_line(data = tsrain[tsrain$date > "2015-08-01"& tsrain$machineID==machine,], aes(x=date,y=rotate))+
      theme_light()+xlab(""),
    ggplot()+geom_line(data = future_Q4[future_Q4$machineID==machine,], aes(x=date,y=pressure), color = "#FFDB6D")+
      geom_line(data = tsrain[tsrain$date > "2015-08-01"& tsrain$machineID==machine,], aes(x=date,y=pressure))+
      theme_light()+xlab(""),
    ggplot()+geom_line(data = future_Q4[future_Q4$machineID==machine,], aes(x=date,y=vibration), color = "#00aa89")+
      geom_line(data = tsrain[tsrain$date > "2015-08-01"& tsrain$machineID==machine,], aes(x=date,y=vibration))+
      theme_light()+xlab(""),
    ggplot()+geom_line(data = future_Q4[future_Q4$machineID==machine,], aes(x=date,y=daysSinceError), color = "#D16103")+
      geom_line(data = tsrain[tsrain$date > "2015-08-01"& tsrain$machineID==machine,], aes(x=date,y=daysSinceError))+
      theme_light(),
    ggplot()+geom_line(data = future_Q4[future_Q4$machineID==machine,], aes(x=date,y=PoF_model12))+
      geom_bar(data = tsrain[tsrain$date > "2015-08-01" & tsrain$machineID==machine,], aes(x=date,y=as.integer(failureYN)), stat = "identity")+theme_light()+ylab("Failure / PoF"),
    ncol = 2)
}

showFP_4machines <- function(machine1, machine2, machine3, machine4){
  grid.arrange(
    ggplot()+
      geom_bar(data=tsest[tsest$machineID==machine1,],
               aes(x=date, y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
      geom_line(data=future_Q4[future_Q4$machineID==machine1,], aes(x=date, y=PoF_model12))+
      theme_light()+ylab("")+xlab(paste("Model",machine1)),
    ggplot()+
      geom_bar(data=tsest[tsest$machineID==machine2,],
               aes(x=date, y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
      geom_line(data=future_Q4[future_Q4$machineID==machine2,], aes(x=date, y=PoF_model12))+
      theme_light()+ylab("")+xlab(paste("Model",machine2)),
    ggplot()+
      geom_bar(data=tsest[tsest$machineID==machine3,],
               aes(x=date, y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
      geom_line(data=future_Q4[future_Q4$machineID==machine3,], aes(x=date, y=PoF_model12))+
      theme_light()+ylab("")+xlab(paste("Model",machine3)),
    ggplot()+
      geom_bar(data=tsest[tsest$machineID==machine4,],
               aes(x=date, y=failureYN), stat = "identity", alpha = 0.5, fill = "#009DA6")+
      geom_line(data=future_Q4[future_Q4$machineID==machine4,], aes(x=date, y=PoF_model12))+
      theme_light()+ylab("")+xlab(paste("Model",machine4)),
    ncol = 2, left = "Probability of failure (PoF)"
  )
}


showFCandFP("4")
showFP_4machines("1","20","40","99")
showFP_4machines("24","50","79","96") # the only machines on which model12 day failure (at least for bs100)
showFCandFP("96") # it started forecasting daysSinceError into the negatives o_O

plot(future_Q4$PoF_model12)

view(future_Q4[future_Q4$Failure_m12==1,])
unique(future_Q4[future_Q4$Failure_m12==1,]$machineID)
```


```{r PUT REAL failureYN in future_Q4}
future_Q4$failureYN_observed <- tsest$failureYN
```



```{r plot examples of predictions for model 12 (on forecasts)}
gridExtra::grid.arrange(ggplot(future_Q4[future_Q4$machineID==1,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 1"),
                        
                        ggplot(future_Q4[future_Q4$machineID==2,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 2"),
                        
                        ggplot(future_Q4[future_Q4$machineID==3,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 3"),
                        
                        ggplot(future_Q4[future_Q4$machineID==4,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 4"),
                        
                        ggplot(future_Q4[future_Q4$machineID==5,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 5"),
                        
                        ggplot(future_Q4[future_Q4$machineID==6,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 6"),
                        
                        ggplot(future_Q4[future_Q4$machineID==7,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 7"),
                        
                        ggplot(future_Q4[future_Q4$machineID==8,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 8"),
                        
                        ggplot(future_Q4[future_Q4$machineID==9,], aes(x=date))+
                            geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
                            geom_line(aes(y=PoF_model12))+ ylim(0,1)+
                            theme_light()+ylab("")+xlab("Machine 9"),
                          
                          ncol = 3, left = "Probability of failure (PoF)"
                        )


gridExtra::grid.arrange(
  ggplot(future_Q4[future_Q4$machineID==24,], aes(x=date))+
    geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
    geom_line(aes(y=PoF_model12))+ ylim(0,1)+
    theme_light()+ylab("")+xlab("Machine 24"),
  
  ggplot(future_Q4[future_Q4$machineID==96,], aes(x=date))+
    geom_bar(aes(y=failureYN_observed), stat = "identity", alpha = 0.5, fill = "#009DA6")+
    geom_line(aes(y=PoF_model12))+ ylim(0,1)+
    theme_light()+ylab("")+xlab("Machine 96"),
  
  ncol = 3, nrow = 3, left = "Probability of failure (PoF)"
  )

mean(future_Q4$PoF_model12)
```



```{r Evaluation of failure prediction Q4}
confusionMatrix(reference = as.factor(tsest$failureYN), as.factor(future_Q4$Failure_m12), positive = "1")
```






```{r Forecasts and failure prediction (2016 Q1)}
# cannot be evaluated as the data doesn't exist
# Just to illustrate how dashboard would look
```



```{r Trying to improve forecasts}
fit_volt <- model(tsrain, 
                  snaive=SNAIVE(volt),
                  tslm=TSLM(volt ~ trend() + season()), #Warning: 100 errors (1 unique) encountered for tslm
                  ets=ETS(volt ~ error() + trend() + season())) #[100] contrasts can be applied only to factors with 2 or more levels
fc_volt <- forecast(fit_volt, new_data = future_Q4)



machine_forecast(fc_volt, tsest, 4)




library(tsibbledata)
olympic_running %>%
  model(lm = TSLM(Time ~ trend()))
olympic_running %>%
  model(lm = TSLM(Time ~ trend())) %>%
  interpolate(olympic_running)

X <- tsrain %>%
  model(lm = TSLM(volt ~ trend() + season()))
Y <- tsrain %>%
  model(lm = TSLM(volt ~ trend() + season())) %>%
  interpolate(tsest)
# we can either (interpolate and merge) or (use forecast) but they don't give exactly the same value





#### following the book: ----
# predictors:
# model and age are unique for each machine, so that doesnt work?

# if it forecasts one row at a time, I may be able to use futureQ4 with the first few lag rows to forecast! :-D
# but that requires that it also puts a new value into the next lag row! :/

# otherwise, using predictors such as one variable to forecast another makes it post ante, not ex ante :(
# or we have to predict one of them first (which ever is best predicted ex ante) and use as predictor for the next, etc.

fit_volt_test <- model(tsrain,
                       simple_lm_lag1 = TSLM(volt ~ lag_1d_volt),
                       multi_lm_IoT = TSLM(volt ~ rotate + pressure + vibration)
                       #special_lm = TSLM(volt ~ trend())
                       ) 
fc_volt_test <- forecast(fit_volt_test, new_data = tsest)
machine_forecast(fc_volt_test, tsest, 1) 
# i can plot multiple machines with : operator,  but looks like it reduces complexity in real IoT measure

machine_report(fit_volt_test[,c(1,3)], 1)



# FPP3 5.5?
sim <- fit_volt |> generate(new_data = tsest, times = 5, bootstrap = TRUE)

tsrain[tsrain$date > "2015-09-01" & tsrain$machineID=="1",] |>
  ggplot(aes(x = date)) +
  geom_line(aes(y = volt)) +
  geom_line(aes(y = .sim, colour = as.factor(.rep)),
    data = sim[sim$machineID=="1" & sim$date < "2015-11-01",]) +
  #labs(title="Google daily closing stock price", y="$US" ) +
  guides(colour = "none")

tsrain[tsrain$machineID=="1",] |>
  ggplot(aes(x = date)) +
  geom_line(aes(y = volt)) +
  geom_line(aes(y = .sim, colour = as.factor(.rep)),
    data = sim[sim$machineID=="1",]) +
  #labs(title="Google daily closing stock price", y="$US" ) +
  guides(colour = "none")




# OLD forecast fitting code: ----
fit_volt <- model(tsrain, TSLM(volt ~ trend() + season()))
fc_volt <- forecast(fit_volt, new_data = future_Q4[,1:2])
machine_report(fit_volt, 1)
machine_forecast(fc_volt, tsest, 1)+ggtitle("TSLM(volt ~ trend() + season())                Machine1")


fit_volt <- model(tsrain, TSLM(volt ~ trend() + season()))
fc_volt <- forecast(fit_volt, new_data = future_Q4[,1:2], bootstrap =T, times=3)
machine_report(fit_volt, 1)
machine_forecast(fc_volt, tsest, 3)+ggtitle("TSLM(volt ~ trend() + season())  +bootstrap*3              Machine1")

fit_volt_STL <- model(tsrain, STL(volt))
components(fit_volt_STL)
```



```{r Trying to make days since LAST Failure}
# should just be days since failure where the 0s are removed and put as one more than the previous row
test_df_daily <- df_daily

# replace 0 days with NA
#test_df_daily$daysSinceFailure[test_df_daily$daysSinceFailure == 0] <- NA

# fill in so the day of failure has the same number as the day before
#test_df_daily <- test_df_daily %>%
#  group_by(machineID) %>%
#  fill(daysSinceFailure)

# make lag column so rows where the number is the same as before can 

# no wait, days where daysSinceFailure == NA make it lagged
#test_df_daily <- test_df_daily %>%
#  group_by(machineID) %>%
#  mutate(daysSinceLastFailure = case_when(
#    daysSinceFailure == NA ~ (lag(daysSinceFailure, 1)+1),
#    daysSinceFailure != NA ~ daysSinceFailure
#  ))



#
test_df_daily <- test_df_daily %>%
  group_by(machineID) %>%
  mutate(
    SinceFailLag = lag(daysSinceFailure, 1),
    daysSinceLastFailure = case_when(
      daysSinceFailure == 0 ~ SinceFailLag+1,
      .default = daysSinceFailure)
    )


view(select(test_df_daily, c("machineID", "date", "failureYN", "daysSinceFailure", "SinceFailLag", "daysSinceLastFailure")))
```


